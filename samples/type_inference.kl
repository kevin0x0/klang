let type = type;
local virtual => debug("not implemented"), traceback();

local Node {
  local parent;

  shared '?' = "Node";

  method init = self => self.parent = self;

  method setparent = (self, parent) => self.parent = parent;
  method getparent = self -> self.parent;

  method find = self -> parent === self and self or parent.find() where let parent = self.getparent();

  method union = (self, other) => self.find().setparent(other.find());

  method unify = (self, other) => {
    self, other = self.find(), other.find();
    if self === other: return true;
    let self_type, other_type = type self, type other;
    if self_type == "InnerNode" and other_type == self_type: {
      let self_children, other_children = self.getchildren(), other.getchildren();
      if self.getop() != other.getop() || $self_children != $other_children: return false;
      self.union(other);
      for i = 0, $self_children:
        if not self_children[i].unify(other_children[i]):
          return false;
      return true;
    }
    if self_type == "TypeVar": return true where self.union(other);
    if other_type == "TypeVar": return true where other.union(self);
    return false;
  };
};

local InnerNode inherit Node: {
  local operator;
  local children;

  shared '?' = "InnerNode";

  method init = (self, operator, children) => {
    Node.init(self);
    self.operator, self.children = operator, children;
  };

  method getop = self -> self.operator;
  method getchildren = self -> self.children;
}

local TypeVar inherit Node: {
  local name;

  shared '?' = "TypeVar";

  method init = (self, name) => {
    Node.init(self);
    self.name = name;
  };
}

method string.find = self -> self;
method string.unify = Node.unify;

local print_type(t, out) => {
  local assign_name(t, visited, namemap, id) => {
    t = t.find();
    if visited[t]: {
      if namemap[t]:
        return id;
      namemap[t] = "t" .. id;
      return id + 1;
    }
    if type t != "InnerNode":
      return id;

    visited[t] = true;

    for child in t.getchildren():
      id = assign_name(child, visited, namemap, id);
    return id;
  };
  t = t.find();
  let namemap = {:};
  assign_name(t, {:}, namemap, 0);

  local get_string(t, namemap, skip_first_name_check) => {
    t = t.find();
    return case type t of
      "string" = t,
      "TypeVar" = t.name,
      "InnerNode" = str where {
        let str = nil;
        if namemap[t] and not skip_first_name_check: {
          str = namemap[t];
        } else {
          str = t.getop() .. "(";
          let delim = "";
          for child in t.getchildren(): {
            str = str .. delim .. get_string(child, namemap);
            delim = ","
          }
          str = str .. ")";
        }
      };
  }

  out.write(get_string(t, namemap));
  let prefix = " where\n    ";
  for typenode, name in namemap: {
    out.write(prefix, name, " = ", get_string(typenode, namemap, true));
    prefix = "\n    ";
  }
  print();
}

local printresult(head, type) => {
  let out = ostream.stdout;
  out.write(head);
  print_type(type, out);
}

let typevarA = new TypeVar("a");
let typevarB = new TypeVar("b");
let typevarC = new TypeVar("c");
let type1 = new InnerNode("function", [new InnerNode("tuple", [typevarA, typevarB]), typevarA]);
let type2 = new InnerNode("function", [new InnerNode("tuple", ["int", "float"]), typevarC]);

if type1.unify(type2): {
  printresult("type1: ", type1);
  printresult("type2: ", type2);
  printresult("a: ", typevarA);
  printresult("b: ", typevarB);
  printresult("c: ", typevarC);
} else {
  to_string("type mismatch");
}
